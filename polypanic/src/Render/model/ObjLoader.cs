using OpenTK.Mathematics;
using System.Globalization;

namespace PolyPanic.Render.Mesh
// and i said i'd keep ai usage low, but this is also generated by claude.... i really need to find proper documentation for this type of stuff instead of just asking claude how it's supposed to be done.
{
    public static class ObjLoader
    {
        public static Mesh LoadFromFile(string filePath)
        {
            if (!File.Exists(filePath))
                throw new FileNotFoundException($"OBJ file not found: {filePath}");

            var vertices = new List<Vector3>();
            var normals = new List<Vector3>();
            var texCoords = new List<Vector2>();
            var faces = new List<Face>();

            string[] lines = File.ReadAllLines(filePath);

            foreach (string line in lines)
            {
                string trimmed = line.Trim();
                if (string.IsNullOrEmpty(trimmed) || trimmed.StartsWith("#"))
                    continue;

                string[] parts = trimmed.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                if (parts.Length == 0)
                    continue;

                switch (parts[0])
                {
                    case "v": // Vertex position
                        if (parts.Length >= 4)
                        {
                            float x = ParseFloat(parts[1]);
                            float y = ParseFloat(parts[2]);
                            float z = ParseFloat(parts[3]);
                            vertices.Add(new Vector3(x, y, z));
                        }
                        break;

                    case "vn": // Vertex normal
                        if (parts.Length >= 4)
                        {
                            float x = ParseFloat(parts[1]);
                            float y = ParseFloat(parts[2]);
                            float z = ParseFloat(parts[3]);
                            normals.Add(new Vector3(x, y, z));
                        }
                        break;

                    case "vt": // Texture coordinate
                        if (parts.Length >= 3)
                        {
                            float u = ParseFloat(parts[1]);
                            float v = ParseFloat(parts[2]);
                            texCoords.Add(new Vector2(u, v));
                        }
                        break;

                    case "f": // Face
                        if (parts.Length >= 4)
                        {
                            var face = new Face();
                            for (int i = 1; i < parts.Length; i++)
                            {
                                var vertex = ParseVertexData(parts[i]);
                                face.Vertices.Add(vertex);
                            }
                            faces.Add(face);
                        }
                        break;
                }
            }

            return BuildMesh(vertices, normals, texCoords, faces);
        }

        private static float ParseFloat(string value)
        {
            return float.Parse(value, CultureInfo.InvariantCulture);
        }

        private static VertexData ParseVertexData(string vertexString)
        {
            string[] indices = vertexString.Split('/');
            var vertex = new VertexData();

            // Position index (required)
            if (indices.Length > 0 && !string.IsNullOrEmpty(indices[0]))
                vertex.PositionIndex = int.Parse(indices[0]) - 1; // OBJ indices are 1-based

            // Texture coordinate index (optional)
            if (indices.Length > 1 && !string.IsNullOrEmpty(indices[1]))
                vertex.TexCoordIndex = int.Parse(indices[1]) - 1;

            // Normal index (optional)
            if (indices.Length > 2 && !string.IsNullOrEmpty(indices[2]))
                vertex.NormalIndex = int.Parse(indices[2]) - 1;

            return vertex;
        }

        private static Mesh BuildMesh(List<Vector3> positions, List<Vector3> normals, 
                                    List<Vector2> texCoords, List<Face> faces)
        {
            var finalVertices = new List<Vector3>();
            var finalNormals = new List<Vector3>();
            var finalTexCoords = new List<Vector2>();
            var indices = new List<uint>();

            var vertexMap = new Dictionary<string, uint>();
            uint currentIndex = 0;

            foreach (var face in faces)
            {
                // Triangulate face (assuming quads can be split into triangles)
                var faceIndices = new List<uint>();

                foreach (var vertex in face.Vertices)
                {
                    string key = $"{vertex.PositionIndex}_{vertex.TexCoordIndex}_{vertex.NormalIndex}";

                    if (!vertexMap.ContainsKey(key))
                    {
                        // Add new unique vertex
                        vertexMap[key] = currentIndex;

                        // Position (required)
                        finalVertices.Add(positions[vertex.PositionIndex]);

                        // Normal (use default if not available)
                        if (vertex.NormalIndex >= 0 && vertex.NormalIndex < normals.Count)
                            finalNormals.Add(normals[vertex.NormalIndex]);
                        else
                            finalNormals.Add(new Vector3(0, 1, 0)); // Default up normal

                        // Texture coordinates (use default if not available)
                        if (vertex.TexCoordIndex >= 0 && vertex.TexCoordIndex < texCoords.Count)
                            finalTexCoords.Add(texCoords[vertex.TexCoordIndex]);
                        else
                            finalTexCoords.Add(new Vector2(0, 0)); // Default UV

                        currentIndex++;
                    }

                    faceIndices.Add(vertexMap[key]);
                }

                // Convert face to triangles
                if (faceIndices.Count >= 3)
                {
                    // Triangle fan triangulation for faces with more than 3 vertices
                    for (int i = 1; i < faceIndices.Count - 1; i++)
                    {
                        indices.Add(faceIndices[0]);
                        indices.Add(faceIndices[i]);
                        indices.Add(faceIndices[i + 1]);
                    }
                }
            }

            return new Mesh(
                finalVertices.ToArray(),
                finalNormals.ToArray(),
                finalTexCoords.ToArray(),
                indices.ToArray()
            );
        }

        private class VertexData
        {
            public int PositionIndex { get; set; } = -1;
            public int TexCoordIndex { get; set; } = -1;
            public int NormalIndex { get; set; } = -1;
        }

        private class Face
        {
            public List<VertexData> Vertices { get; set; } = new List<VertexData>();
        }
    }
}